<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <title>å®Ÿè»Šè©•ä¾¡æ”¯æ´ãƒ„ãƒ¼ãƒ«</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.webmanifest" />
  <meta name="theme-color" content="#0ea5e9" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="leaflet.css" />

  <style>
    :root { --ui-bg:#fff; --ui-shadow: 0 6px 24px rgba(0,0,0,.18); }
    html,body,#map { height: 100%; margin: 0; }
    #map { background:#f2f2f2; }

    /* ä¸Šéƒ¨ãƒ‘ãƒãƒ« */
    #panel {
      position: absolute; inset: 10px auto auto 10px;
      z-index: 1000; background: var(--ui-bg);
      padding: 10px 12px; border-radius: 14px; box-shadow: var(--ui-shadow);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      min-width: 280px; max-width: min(94vw, 420px);
    }
    #panel h1 { margin: 0 0 8px; font-size: 14px; font-weight: 700; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin: 6px 0; }
    label { font-size: 12px; }
    .small { font-size: 11px; color: #555; }
    .badge { display:inline-block; padding:2px 6px; background:#eef; border:1px solid #ccd; border-radius: 6px; font-size: 11px; }
    button, input[type="file"] { font: inherit; }
    button { cursor: pointer; padding: 6px 10px; border-radius: 10px; border: 1px solid #ddd; background:#fff; }
    #track { background:#16a34a; color:#fff; border-color:#16a34a; }
    #stop { background:#ef4444; color:#fff; border-color:#ef4444; }
    #recenter { background:#0ea5e9; color:#fff; border-color:#0ea5e9; }

    /* å³ä¸‹ã®ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã€Œç¾åœ¨åœ°ã¸ã€ */
    #fab-recenter {
      position: absolute; right: 14px; bottom: 14px; z-index: 1000;
      width: 50px; height: 50px; border-radius: 50%;
      display:grid; place-items:center;
      background:#0ea5e9; color:#fff; box-shadow: var(--ui-shadow); border:none;
      font-size: 20px; cursor: pointer;
    }

    /* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ */
    input[type="range"] { width: 100%; }

    /* ãƒ¢ãƒã‚¤ãƒ«ã§ãƒ‘ãƒãƒ«ãŒé‚ªé­”ãªæ™‚ã«ãŸãŸã‚€ */
    #togglePanel {
      position:absolute; left:10px; top:10px; z-index:1001;
      background:#0ea5e9; color:#fff; border:none; border-radius: 10px;
      box-shadow: var(--ui-shadow); padding:6px 10px; display:none;
    }
    @media (max-width: 640px) {
      #togglePanel { display:block; }
      #panel.compact { display: none; }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <button id="togglePanel">ãƒ¡ãƒ‹ãƒ¥ãƒ¼</button>

  <div id="panel">
    <h1>å®Ÿè»Šè©•ä¾¡æ”¯æ´ãƒ„ãƒ¼ãƒ«</h1>

    <div class="row">
      <input type="file" id="file" accept=".kml,.kmz" />
      <button id="clear">ã‚¯ãƒªã‚¢</button>
    </div>

    <div class="row">
      <button id="track">ä½ç½®è¿½è·¡ã‚’é–‹å§‹</button>
      <button id="stop">åœæ­¢</button>
      <button id="recenter">ç¾åœ¨åœ°ã¸</button>
      <label style="display:inline-flex; align-items:center; gap:6px;">
        <input type="checkbox" id="follow" checked /> è‡ªå‹•è¿½å¾“
      </label>
    </div>

    <div class="row">
      <label>é€šçŸ¥è·é›¢: <span id="thv" class="badge">100m</span></label>
      <input id="th" type="range" min="20" max="300" value="100" />
    </div>

    <div class="row">
      <button id="tts">éŸ³å£°ãƒ†ã‚¹ãƒˆ</button>
      <span class="small" id="stat"></span>
    </div>

    <div class="small">
      â€» ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ™‚ã«è¡¨ç¤ºã—ãŸåœ°å›³ã¯è‡ªå‹•çš„ã«ç«¯æœ«ã¸ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã€åœå¤–ã§ã‚‚è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚
    </div>
  </div>

  <!-- å³ä¸‹ã®ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ç¾åœ¨åœ°ãƒœã‚¿ãƒ³ï¼ˆè¦ªæŒ‡ã§æŠ¼ã—ã‚„ã™ã„ï¼‰ -->
  <button id="fab-recenter" title="ç¾åœ¨åœ°ã¸">ğŸ“</button>

  <!-- PWA: Service Worker ç™»éŒ² -->
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js').catch(()=>{});
    }
  </script>

  <!-- ä¾å­˜ãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
  <script src="leaflet.js"></script>
  <script src="jszip.min.js"></script>
  <script src="togeojson.umd.js"></script>

  <script>
    // --- Leaflet ãƒãƒƒãƒ—åˆæœŸåŒ– ---
    const map = L.map('map', { zoomControl: true }).setView([35.0, 135.0], 14);

    // OSM ã‚¿ã‚¤ãƒ«ï¼ˆå˜ä¸€ãƒ›ã‚¹ãƒˆ + CORS æŒ‡å®šï¼‰â€»SWãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥
    const osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      crossOrigin: true,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // --- çŠ¶æ…‹ ---
    let threshold = 100;                // é€šçŸ¥è·é›¢ï¼ˆmï¼‰
    let points = [];                    // {latlng, name, desc, announced}
    let watchId = null;
    let meLayer = null;                 // ç¾åœ¨åœ°è¡¨ç¤º
    let routeLayer = null, pointLayer = null;
    let lastHere = null;                // æœ€çµ‚ç¾åœ¨åœ°
    let follow = true;                  // è‡ªå‹•è¿½å¾“

    // --- è¦ç´  ---
    const elTh   = document.getElementById('th');
    const elThV  = document.getElementById('thv');
    const elStat = document.getElementById('stat');
    const elFollow = document.getElementById('follow');
    const togglePanelBtn = document.getElementById('togglePanel');
    const panel = document.getElementById('panel');

    // --- UI ã‚¤ãƒ™ãƒ³ãƒˆ ---
    togglePanelBtn.addEventListener('click', () => {
      panel.classList.toggle('compact');
    });

    elTh.addEventListener('input', () => {
      threshold = +elTh.value;
      elThV.textContent = `${threshold}m`;
    });

    elFollow.addEventListener('change', () => {
      follow = elFollow.checked;
      if (follow && lastHere) map.setView(lastHere);
    });

    document.getElementById('recenter').addEventListener('click', recenterNow);
    document.getElementById('fab-recenter').addEventListener('click', recenterNow);
    function recenterNow() {
      if (lastHere) {
        follow = true;
        elFollow.checked = true;
        map.setView(lastHere, map.getZoom() < 16 ? 16 : map.getZoom());
      } else {
        // æœ€åˆã®ä½ç½®å–å¾—ï¼ˆå˜ç™ºï¼‰
        navigator.geolocation.getCurrentPosition(
          pos => {
            const here = L.latLng(pos.coords.latitude, pos.coords.longitude);
            map.setView(here, 16);
          },
          err => alert('ä½ç½®å–å¾—ã«å¤±æ•—: ' + err.message),
          { enableHighAccuracy: true, timeout: 10000 }
        );
      }
    }

    document.getElementById('tts').addEventListener('click', () => speak('éŸ³å£°ãƒ†ã‚¹ãƒˆã§ã™'));

    document.getElementById('clear').addEventListener('click', () => {
      if (routeLayer) map.removeLayer(routeLayer);
      if (pointLayer) map.removeLayer(pointLayer);
      points = [];
    });

    document.getElementById('track').addEventListener('click', () => {
      if (watchId) navigator.geolocation.clearWatch(watchId);
      watchId = navigator.geolocation.watchPosition(onPos, onErr, {
        enableHighAccuracy: true, maximumAge: 1000, timeout: 15000
      });
    });

    document.getElementById('stop').addEventListener('click', () => {
      if (watchId) { navigator.geolocation.clearWatch(watchId); watchId = null; }
      elStat.textContent = '';
    });

    document.getElementById('file').addEventListener('change', onFile);

    // åœ°å›³ã‚’è§¦ã£ãŸã‚‰è‡ªå‹•è¿½å¾“ OFF
    map.on('dragstart zoomstart', () => { follow = false; elFollow.checked = false; });

    // --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---
    function speak(text) {
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'ja-JP';
      try { speechSynthesis.speak(u); } catch {}
    }

    function dist(a, b) {
      const R = 6371000, toRad = d => d * Math.PI/180;
      const dlat = toRad(b.lat - a.lat), dlon = toRad(b.lng - a.lng);
      const s = Math.sin(dlat/2)**2 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*Math.sin(dlon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(s));
    }

    function stripHtml(html) {
      if (!html) return '';
      const tmp = document.createElement('div');
      tmp.innerHTML = html;
      return (tmp.textContent || tmp.innerText || '').trim();
    }

    // --- KML/KMZ ãƒ­ãƒ¼ãƒ€ ---
    async function onFile(ev) {
      const f = ev.target.files[0];
      if (!f) return;

      const isKMZ = /\.kmz$/i.test(f.name);
      let kmlText = null;

      try {
        if (isKMZ) {
          const buf = await f.arrayBuffer();
          const zip = await JSZip.loadAsync(buf);
          let kmlEntry = null;
          zip.forEach((p, entry) => { if (!kmlEntry && p.toLowerCase().endsWith('.kml')) kmlEntry = entry; });
          if (!kmlEntry) return alert('KMZå†…ã«KMLãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
          kmlText = await kmlEntry.async('string');
        } else {
          kmlText = await f.text();
        }
      } catch (e) {
        alert('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã«å¤±æ•—: ' + e.message);
        return;
      }

      const kmlDom = new DOMParser().parseFromString(kmlText, 'text/xml');
      const gj = toGeoJSON.kml(kmlDom);

      // æ—¢å­˜ãƒ¬ã‚¤ãƒ¤å‰Šé™¤
      if (routeLayer) map.removeLayer(routeLayer);
      if (pointLayer) map.removeLayer(pointLayer);
      points = [];

      // ãƒ«ãƒ¼ãƒˆï¼ˆLineString / MultiLineStringï¼‰
      const lineFeats = gj.features.filter(ft => ft.geometry && /Line/i.test(ft.geometry.type));
      const lines = lineFeats.map(ft =>
        L.polyline(ft.geometry.coordinates.map(c => [c[1], c[0]]), { color:'#2b8a3e', weight:4 })
      );
      if (lines.length) routeLayer = L.layerGroup(lines).addTo(map);

      // ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆï¼ˆPointï¼‰
      const ptFeats = gj.features.filter(ft => ft.geometry && ft.geometry.type === 'Point');
      pointLayer = L.geoJSON({ type: 'FeatureCollection', features: ptFeats }, {
        pointToLayer: (ft, latlng) => L.circleMarker(latlng, {
          radius: 7, color:'#1e3a8a', weight: 2, fillColor:'#60a5fa', fillOpacity:.9
        }),
        onEachFeature: (ft, layer) => {
          const name = (ft.properties && ft.properties.name) ? stripHtml(ft.properties.name) : 'ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆ';
          const descRaw = (ft.properties && ft.properties.description) ? ft.properties.description : '';
          const desc = stripHtml(descRaw);
          layer.bindPopup(`<b>${name}</b><br>${desc}`);
          points.push({ latlng: layer.getLatLng(), name, desc, announced: false });
        }
      }).addTo(map);

      // ãƒ“ãƒ¥ãƒ¼åˆã‚ã›
      const group = [];
      if (routeLayer) group.push(routeLayer);
      if (pointLayer) group.push(pointLayer);
      if (group.length) {
        const g = L.featureGroup(group);
        map.fitBounds(g.getBounds().pad(0.2));
      }
    }

    // --- ç¾åœ¨åœ°å‡¦ç† ---
    function onPos(pos) {
      const { latitude, longitude, accuracy, speed } = pos.coords;
      const here = L.latLng(latitude, longitude);
      lastHere = here;

      elStat.textContent = `ç²¾åº¦ ${Math.round(accuracy||0)}m / é€Ÿåº¦ ${speed!=null ? Math.round(speed*3.6) : '-'}km/h`;

      if (!meLayer) {
        meLayer = L.circleMarker(here, { radius: 8, color:'#dc2626', weight:3, fillColor:'#fecaca', fillOpacity:1 })
          .addTo(map);
      } else {
        meLayer.setLatLng(here);
      }

      if (follow) map.panTo(here, { animate: false });

      // è·é›¢åˆ¤å®šï¼ˆæœªé€šçŸ¥ã®ã¿ï¼‰
      for (const p of points) {
        if (p.announced) continue;
        if (dist(here, p.latlng) <= threshold) {
          p.announced = true;
          speak(`${p.name}ã€‚ ${p.desc}`);
        }
      }
    }
    function onErr(err) {
      alert('ä½ç½®å–å¾—ã«å¤±æ•—: ' + err.message);
    }
  </script>
</body>
</html>
